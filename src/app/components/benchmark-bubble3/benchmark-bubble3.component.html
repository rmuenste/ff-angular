<mat-tab-group>
  <!-- Introductionab -->
  <mat-tab label="Introduction">
    <div class="heading-wrapper">
      <h4 class="my-h4">
      Three-dimensional rising bubbles
      </h4>
    </div>
    <div class="text-wrapper">
    We provide the computational details of a 3D multiphase flow benchmark problem which follows its already well-established 2D counterpart. The only introduced difference
    with respect to 2D benchmark case (aside of the additional spatial dimension) is the type of boundary condition applied at the side of the channel which according to the
    original 2D is attributed to free slip boundary condition, but in the 3D benchmark it is related to a no slip boundary condition.
    </div>
    <div class="text-wrapper">
      In the table below we list the parameters of the meshes used in the computations. As we can see, meshes of different refinement levels
      are used in our simulations. The refinement levels are created by regular refinement of the same base mesh. We show the problem resolution <app-mathjax [content]="'$(mx, my, mz)$'"></app-mathjax>
      , the mesh resolution <app-mathjax [content]="'$(nx, ny, nz)$'"></app-mathjax>, the number of elements (NEL), the number of Q2 degrees of freedom (dof) and the total number of dofs.
    </div>
    <div class="table-wrapper">
      <table mat-table [dataSource]="dataSourceMesh" class="mat-elevation-z8">
        <!-- Level Column -->
        <ng-container matColumnDef="lvl">
          <th mat-header-cell *matHeaderCellDef> Level </th>
          <td mat-cell *matCellDef="let element"> {{element.lvl}} </td>
        </ng-container>

          <ng-container matColumnDef="mx">
            <th mat-header-cell *matHeaderCellDef> mx </th>
            <td mat-cell *matCellDef="let element"> {{element.mx}} </td>
          </ng-container>

          <ng-container matColumnDef="my">
            <th mat-header-cell *matHeaderCellDef> my </th>
            <td mat-cell *matCellDef="let element"> {{element.my}} </td>
          </ng-container>

          <ng-container matColumnDef="mz">
            <th mat-header-cell *matHeaderCellDef> mz </th>
            <td mat-cell *matCellDef="let element"> {{element.mz}} </td>
          </ng-container>

          <ng-container matColumnDef="nx">
            <th mat-header-cell *matHeaderCellDef> nx </th>
            <td mat-cell *matCellDef="let element"> {{element.nx}} </td>
          </ng-container>

          <ng-container matColumnDef="ny">
            <th mat-header-cell *matHeaderCellDef> ny </th>
            <td mat-cell *matCellDef="let element"> {{element.ny}} </td>
          </ng-container>

          <ng-container matColumnDef="nz">
            <th mat-header-cell *matHeaderCellDef> nz </th>
            <td mat-cell *matCellDef="let element"> {{element.nz}} </td>
          </ng-container>

          <ng-container matColumnDef="nel">
            <th mat-header-cell *matHeaderCellDef> NEL </th>
            <td mat-cell *matCellDef="let element"> {{element.nel}} </td>
          </ng-container>

          <ng-container matColumnDef="nq2">
            <th mat-header-cell *matHeaderCellDef> #Q2 </th>
            <td mat-cell *matCellDef="let element"> {{element.nq2}} </td>
          </ng-container>

          <ng-container matColumnDef="tdof">
            <th mat-header-cell *matHeaderCellDef> Total Dofs </th>
            <td mat-cell *matCellDef="let element"> {{element.tdof}} </td>
          </ng-container>

          <tr mat-header-row *matHeaderRowDef="displayedColumnsMesh"></tr>
          <tr mat-row *matRowDef="let row; columns: displayedColumnsMesh;"></tr>
      </table>
    </div>
    <!--
    <div class="video-wrapper">
    <h4>Video Rising Bubble 3D</h4>
      <video width="624" height="351" controls>
        <source src="assets/test.ogv" type="video/ogv">
        <source src="assets/risingbubble2.mp4" type="video/mp4">
      </video>
    </div>
    -->
  </mat-tab>
  <!-- Definition Tab -->
  <mat-tab label="Definition">
    <div class="heading-wrapper">
      <h4 class="my-h4">
      Geometry and flow configurations
      </h4>
    </div>
    <div class="text-wrapper">
     The initial configuration, see the figure below,
     consists of a circular bubble of radius <app-mathjax [content]="'$r_0 = 0.25$ centered at $(x,y) = (0.5, 0.5)$'"></app-mathjax> in a
     1 by 2 cuboid domain. The density of the bubble is smaller than that of the
     surrounding fluid <app-mathjax [content]="'$(\\rho_1 \\lt \\rho_2)$'"></app-mathjax>. The no-slip boundary condition (<app-mathjax [content]="'$\\mathbf{u}=0$'"></app-mathjax>)
     is used on all boundaries.
    </div>
     <div class="im-div">
       <h3 class="mat-h3">Initial configuration and boundary conditions for the test cases</h3>
       <img src="assets/geometry3D.png" alt="geometry">
     </div>
     <div class="text-wrapper">
     The table below lists the fluid and physical parameters which specify the test cases. The
     evolution of the bubbles should be tracked for 3 time units during which the defined
     benchmark quantities should be measured. The first test case models a rising bubble with Reynolds
     number <app-mathjax [content]="'$Re=35$'"></app-mathjax>, Eötvös number <app-mathjax [content]="'$Eo=10$'"></app-mathjax>, and both density and viscosity ratios equal to 10.
     </div>
<div class="table-wrapper">
<table mat-table [dataSource]="dataSource" class="mat-elevation-z8">

  <!--- Note that these columns can be defined in any order.
        The actual rendered columns are set as a property on the row definition" -->

  <!-- Position Column -->
  <ng-container matColumnDef="position">
    <th mat-header-cell *matHeaderCellDef> TestCase </th>
    <td mat-cell *matCellDef="let element"> {{element.position}} </td>
  </ng-container>

  <!-- Name Column -->
  <ng-container matColumnDef="p1">
    <th mat-header-cell *matHeaderCellDef> ρ<sub>1</sub> </th>
    <td mat-cell *matCellDef="let element"> {{element.p1}} </td>
  </ng-container>

  <!-- Weight Column -->
  <ng-container matColumnDef="p2">
    <th mat-header-cell *matHeaderCellDef> ρ<sub>2</sub> </th>
    <td mat-cell *matCellDef="let element"> {{element.p2}} </td>
  </ng-container>

  <!-- Symbol Column -->
  <ng-container matColumnDef="mu1">
    <th mat-header-cell *matHeaderCellDef> μ<sub>1</sub> </th>
    <td mat-cell *matCellDef="let element"> {{element.mu1}} </td>
  </ng-container>

  <ng-container matColumnDef="mu2">
    <th mat-header-cell *matHeaderCellDef> μ<sub>2</sub> </th>
    <td mat-cell *matCellDef="let element"> {{element.mu2}} </td>
  </ng-container>

  <ng-container matColumnDef="g">
    <th mat-header-cell *matHeaderCellDef> g </th>
    <td mat-cell *matCellDef="let element"> {{element.g}} </td>
  </ng-container>

  <ng-container matColumnDef="sigma">
    <th mat-header-cell *matHeaderCellDef> <app-mathjax [content]="'$\\sigma$'"></app-mathjax> </th>
    <td mat-cell *matCellDef="let element"> {{element.sigma}} </td>
  </ng-container>

  <ng-container matColumnDef="re">
    <th mat-header-cell *matHeaderCellDef> <app-mathjax [content]="'$Re$'"></app-mathjax> </th>
    <td mat-cell *matCellDef="let element"> {{element.re}} </td>
  </ng-container>

  <ng-container matColumnDef="eo">
    <th mat-header-cell *matHeaderCellDef> <app-mathjax [content]="'$Eo$'"></app-mathjax> </th>
    <td mat-cell *matCellDef="let element"> {{element.eo}} </td>
  </ng-container>

  <ng-container matColumnDef="rel">
    <th mat-header-cell *matHeaderCellDef> <app-mathjax [content]="'$\\rho_1 / \\rho_2$'"></app-mathjax> </th>
    <td mat-cell *matCellDef="let element"> {{element.rel}} </td>
  </ng-container>

  <ng-container matColumnDef="relmu">
    <th mat-header-cell *matHeaderCellDef> <app-mathjax [content]="'$\\mu_1 / \\mu_2$'"></app-mathjax> </th>
    <td mat-cell *matCellDef="let element"> {{element.relmu}} </td>
  </ng-container>

  <tr mat-header-row *matHeaderRowDef="displayedColumnsPhysical"></tr>
  <tr mat-row *matRowDef="let row; columns: displayedColumnsPhysical;"></tr>
</table>
</div>
<div class="text-wrapper">
The considered benchmark quantities are selected as for the original 2D benchmark, namely:
<!--

<mat-list>
 <mat-list-item> <b>Bubble Size: </b> Size of the bubble in two different directions, namely in the rise direction (
 (normalized
w.r.t.
 initial bubble size
) and in a perpendicular to rise direction being aligned with one of the cartesian axis (
 or
) expressed as.
 </mat-list-item>
 <mat-list-item> Bubble Sphericity </mat-list-item>
 <mat-list-item> Rise Velocity </mat-list-item>
</mat-list>
-->

<div class="definition-wrapper">
  <p class="definition-heading">Bubble Size</p>
  <div>
  Size of the bubble in two different directions, namely in the rise direction <app-mathjax [content]="'$z$'"></app-mathjax> expressed as
  <app-mathjax [content]="'$R_z / R_0 $'"></app-mathjax> (normalized w.r.t. initial bubble size <app-mathjax [content]="'$R_0 $'"></app-mathjax>) and in a perpendicular
  to rise direction being aligned with one of the cartesian axis (<app-mathjax [content]="'$x$'"></app-mathjax> or <app-mathjax [content]="'$y$'"></app-mathjax>) expressed
  as <app-mathjax [content]="'$R_{x,y} / R_0 $'"></app-mathjax>.
  </div>
</div>

<div class="definition-wrapper">
  <p class="definition-heading">Bubble Sphericity</p>
  <div>
    The "degree of sphericity" in <app-mathjax [content]="'$\\mathbb{R}^3$'"></app-mathjax> can be defined as
    <div class="equation-wrapper">
      <app-mathjax [content]="'$\\frac{A_0}{A} = \\frac{4 \\pi R^2_0}{A}$'"></app-mathjax>
    </div>
    Here, <app-mathjax [content]="'$A_0 $'"></app-mathjax> denotes the interfacial area of an equivalent (in terms of volume) spherical bubble of radius <app-mathjax [content]="'$R_0 $'"></app-mathjax>
    (i.e. the surface area of the initial bubble) and <app-mathjax [content]="'$A$'"></app-mathjax> denotes the interfacial area of the simulated bubble at the given time level.
  </div>
</div>

<div class="definition-wrapper">
  <p class="definition-heading">Rise Velocity</p>
  <div>
    The mean velocity with which the bubble is rising or moving and is defined as:
    <div class="equation-wrapper">
      <app-mathjax [content]="'$\\mathbf{U}_c = \\frac{ \\int_{\\Omega_2} \\mathbf{u} \\; \\mathrm{d}x }{ \\int_{\\Omega_2} 1\\; \\mathrm{d}x }$'"></app-mathjax>
    </div>
    where <app-mathjax [content]="'$\\Omega_2$'"></app-mathjax> denotes the region that the bubble occupies. The velocity component in the direction opposite to the gravity vector is then
    denoted as rise velocity <app-mathjax [content]="'$V_c$'"></app-mathjax> for which the stationary limit is called terminal velocity.
  </div>
</div>
According to the definition of this benchmark problem, the evolution of all these quantities is to be predicted in the course of a transient simulation starting with a bubble at rest, which
due to the buyoancy forces begins to rise in the surrounding fluid giving rise to an interplay of surface tension forces with the hydrodynamic forces in form of deformation of the bubble
surface. The dimensionless timespan of the simulation covers the time interval from t = 0 up to t = 3.
</div>
</mat-tab>
<!-- Results Tab -->
<mat-tab label="Results">
    <div class="heading-wrapper">
     <h4 class="my-h4"> Results </h4>
    </div>

<!-- Results Tab
 -->
  <div fxLayout="row wrap" fxLayoutAlign="space-around space-around" fxLayoutGap="16px">

   <div fxFlex.gt-sm="40%" fxFlex.lt-lg="100%">
     <div *ngIf="sphericityGraph; else loading">
       <app-plot-component
         [graph]="sphericityGraph"
       ></app-plot-component>
     </div>
   </div>


  <div fxFlex.gt-sm="40%" fxFlex.lt-lg="100%">
    <div *ngIf="graphMassConservation; else loading">
      <app-plot-component
        [graph]="graphMassConservation"
      ></app-plot-component>
    </div>
  </div>

  <div fxFlex.gt-sm="40%" fxFlex.lt-lg="100%">
    <div *ngIf="graphSize; else loading">
      <app-plot-component
        [graph]="graphSize"
      ></app-plot-component>
    </div>
  </div>

  <div fxFlex.gt-sm="40%" fxFlex.lt-lg="100%">
    <div *ngIf="graphSurface; else loading">
      <app-plot-component
        [graph]="graphSurface"
      ></app-plot-component>
    </div>
  </div>
</div>


</mat-tab>
<!-- Reference Data -->
<mat-tab label="Reference Data"> 
  <div class="text-wrapper">
    <h3>Reference Data Format Description for Plotly Visualization</h3>
    <h3>Overview</h3>
    <p>
        The data is structured as a JSON array where each element of the array represents a different spatial resolution of the same dataset. Each element contains four curves, representing the same dataset at different time resolutions. This hierarchical structure allows for detailed analysis of how both spatial and temporal resolutions impact the data.
    </p>
    <h3>Structure</h3>
    <ol>
        <li>
            <strong>Top-Level Array</strong>: This contains three elements, each representing a different spatial resolution of the dataset.
            <ul>
                <li>The <strong>first element</strong> is the coarsest spatial resolution.</li>
                <li>The <strong>third element</strong> is the highest spatial resolution.</li>
            </ul>
        </li>
        <li>
            <strong>Element Structure</strong>: Each element in the top-level array is an object that contains four curves. These curves are differentiated by the time resolution of their x-components.
<pre ngNonBindable>
  <code>&#123;
  "data": [
    &#123;
      "x": [ ... ], // x-values representing time
      "y": [ ... ], // y-values representing the data
      "type": "scatter", // Plot type for Plotly
      "name": "dt=time resolution", // Curve name indicating time resolution
      "marker": &#123;
        "color": "color" // Color for the curve
      &#125;
    &#125;,
    // Three more curves with different time resolutions
  ]
&#125;
</code>
</pre>
        </li>
    </ol>
    <h3>Example</h3>
<pre ngNonBindable>
      <code>[
  &#123;
    "data": [
      &#123;
        "x": [0.001, 0.101, 0.201, ...],
        "y": [1.000003, 0.9999997, 0.9999737, ...],
        "type": "scatter",
        "name": "dt=1.0E-3",
        "marker": &#123;"color": "dodgerblue"&#125;
      &#125;,
      &#123;
        "x": [0.001, 0.101, 0.201, ...],
        "y": [1.000003, 1.000003, 0.9999941, ...],
        "type": "scatter",
        "name": "dt=0.25E-3",
        "marker": &#123;"color": "orange"&#125;
      &#125;,
      &#123;
        "x": [0.001, 0.101, 0.201, ...],
        "y": [1.000003, 1.000003, 0.9999992, ...],
        "type": "scatter",
        "name": "dt=0.0625E-3",
        "marker": &#123;"color": "green"&#125;
      &#125;,
      &#123;
        "x": [0.001, 0.101, 0.201, ...],
        "y": [1.000003, 1.000004, 1.000001, ...],
        "type": "scatter",
        "name": "dt=0.0156E-3",
        "marker": &#123;"color": "red"&#125;
      &#125;
    ]
  &#125;,
  // Two more elements with higher spatial resolutions
]</code>
</pre>
    <h3>Key Details</h3>
    <ul>
        <li>
            <strong>Spatial Resolution</strong>: The three elements of the top-level array represent increasing spatial resolutions.
            <ul>
                <li>The first element has the coarsest spatial resolution.</li>
                <li>The third element has the finest spatial resolution.</li>
            </ul>
        </li>
        <li>
            <strong>Time Resolution</strong>: Each element contains four curves, each representing a different time resolution (<code>dt</code>). The time resolutions are indicated in the <code>name</code> field of each curve.
            <ul>
                <li>For example, <code>name: "dt=1.0E-3"</code> indicates a time resolution of 1.0E-3.</li>
            </ul>
        </li>
        <li>
            <strong>Colors</strong>: Each curve has a distinct color to differentiate between the different time resolutions within the same spatial resolution.
        </li>
        <li>
            <strong>Plotly Compatibility</strong>: The structure is compatible with the Plotly library for visualization. The <code>type: "scatter"</code> field ensures that the data is plotted as a scatter plot.
        </li>
    </ul>
    <h3>Usage</h3>
    <p>
        To visualize the data using Plotly, you can iterate over the top-level array to create separate plots for each spatial resolution. Within each plot, you can include the four curves representing different time resolutions.
    </p>
<pre ngNonBindable>
<code>
  // Assuming `data` is the JSON array
  const plotData = data[0].data; // Use the first element for the coarsest spatial resolution

  Plotly.newPlot('plotDiv', plotData, &#123;
    title: 'Data Plot',
    xaxis: &#123; title: 'Time' &#125;,
    yaxis: &#123; title: 'Value' &#125;
  &#125;);
</code>
</pre>
    <p>
        This structure allows for detailed and flexible analysis of how both spatial and temporal resolutions impact the dataset, providing a comprehensive view for analysis and visualization. Below the different data sets can be downloaded:
    </p>


  </div>
  <div class="table-wrapper">
    <table mat-table [dataSource]="dataSourceFiles" class="mat-elevation-z8">
  
      <!--- Note that these columns can be defined in any order.
            The actual rendered columns are set as a property on the row definition" -->
  
      <!-- File Column -->
      <ng-container matColumnDef="file">
        <th mat-header-cell *matHeaderCellDef> File </th>
        <td mat-cell *matCellDef="let element"> {{element.file}} </td>
      </ng-container>
  
      <!-- Action Column -->
      <ng-container matColumnDef="action">
        <th mat-header-cell *matHeaderCellDef> Action </th>
        <td mat-cell *matCellDef="let element">
          <a [href]="element.fileURL">{{element.action}}</a>
        </td>
      </ng-container>
  
      <tr mat-header-row *matHeaderRowDef="displayedColumnsFiles"></tr>
      <tr mat-row *matRowDef="let row; columns: displayedColumnsFiles;"></tr>
    </table>
  </div>
</mat-tab>

</mat-tab-group>


<ng-template #loading>
  <p>Loading data...</p>
</ng-template>
